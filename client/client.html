<!DOCTYPE html>
<html lang="en">
<head>
  <!-- import the websocket client library. You can code websockets from scratch
       but we will just import a library. In this case we are using socket.io which is 
       one of the most popular and feature rich websocket libraries.

       You can point the src for the script to any host online, but
       by default the socket.io nodejs library will host the client library
       online at your node.js address under /socket.io/socket.io.js 
       You can disable that on the server if desired
  -->
  <script src="/socket.io/socket.io.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.34/browser.min.js"></script>
  <script type="text/babel">
    (function(){
      "use strict";

      //canvas atts
      let canvas;
      let ctx;

      //io atts
      let socket;
      let board;
      let userColor;
      let opponentColor;
      let myTurn;
      let selectedPiece = -1;
      let pieceCount = 12;
      
      const updateBoard = () => {
        //drawbackdrop
        ctx.fillStyle = '#F5DEB3';
        ctx.fillRect(75, 75, 450, 450);
        
        //draw the board
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            ctx.fillStyle = board.colors[j + (8 * i)];
            ctx.fillRect(100 + (50 * j), 100 + (50 * i), 50, 50);
          }
        }
        
        //draw the pieces
        for (let i = 0; i < 8; i++) {
          for (let j = 0; j < 8; j++) {
            if (board.spaces[j + (8 * i)] === 1) {
              ctx.fillStyle = 'red';
              ctx.beginPath();
              ctx.arc(125 + (50 * j), 125 + (50 * i), 20, 0, Math.PI * 2);
              ctx.fill();
            }
            
            if (board.spaces[j + (8 * i)] === 2) {
              ctx.fillStyle = 'blue';
              ctx.beginPath();
              ctx.arc(125 + (50 * j), 125 + (50 * i), 20, 0, Math.PI * 2);
              ctx.fill();
            }
            
            if (j + (8 * i) === selectedPiece) {
              ctx.lineWidth = 2;
              ctx.strokeStyle = 'yellow';
              ctx.strokeRect(100 + (50 * j), 100 + (50 * i), 50, 50);
            }
          }
        }
      }
      
      const update = (data) => {
        requestAnimationFrame(update);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        updateBoard();
        
        if (myTurn) {
          if (userColor === 1) {
            ctx.fillStyle = 'red';
            ctx.fillText('Your Turn', 100, 50);
          } else {
            ctx.fillText('Your Turn', 100, 550);
          }
        } else {
          if (userColor === 1) {
            ctx.fillStyle = 'blue';
            ctx.fillText("Opponent's Turn", 100, 550);
          } else {
            ctx.fillText("Opponent's Turn", 100, 50);
          }
        }
      }
      
      const clickedRectangle = (clickLoc, x, y, width, height) => {
        if (clickLoc.pageX - clickLoc.target.offsetLeft > x && clickLoc.pageX - clickLoc.target.offsetLeft < x + width && clickLoc.pageY - clickLoc.target.offsetTop > y && clickLoc.pageY - clickLoc.target.offsetTop < y + height) {
          return true;
        } else {
          return false;
        }
      }
      
      const ioInit = () => {
        socket = io.connect();
        let user = "";
        
        socket.on('connect', () => {
          socket.emit('join', {});
          ctx.clearRect(0,0,canvas.width, canvas.height);
          ctx.fillText('Waiting for opponent...', 300, 255);
          canvas.onclick = null;
        });

        socket.on('load', (data) => {
          board = data.board;
          if (data.color === 1) {
            userColor = 1;
            opponentColor = 2;
            myTurn = true;
          } else {
            userColor = 2;
            opponentColor = 1;
            myTurn = false;
          }
          
          canvas.onclick = (e) => {
            if (myTurn) {
              for (let i = 0; i < 8; i++) {
                for (let j = 0; j < 8; j++) {
                  //current space for ease
                  let currentSpace = j + (8 * i);
                  
                  //check if we are selecting a piece
                  if (clickedRectangle(e, 100 + (50 * j), 100 + (50 * i), 50, 50) && board.spaces[currentSpace] === userColor) {
                    selectedPiece = j + (8 * i);
                  }
                  
                  //check if piece is selected
                  if (selectedPiece != -1) {
                    //check if moving into empty space
                    if (clickedRectangle(e, 100 + (50 * j), 100 + (50 * i), 50, 50) && board.spaces[currentSpace] === 0) {
                      //check if it's a valid space
                      if (userColor === 1) {
                        //check if moving into adjacent spaces
                        if ((currentSpace === selectedPiece + 7 && j != 0) || 
                            (currentSpace === selectedPiece + 9 && j != 8) || 
                            (board.spaces[selectedPiece] === -userColor && ((currentSpace === selectedPiece - 7 && j!= 0) || (currentSpace === selectedPiece - 9 && j != 8)))) {
                          board.spaces[currentSpace] = board.spaces[selectedPiece];
                          board.spaces[selectedPiece] = 0;
                          socket.emit('clientUpdate', { boardSpaces: board.spaces, pieceCount: pieceCount, selectedPiece: selectedPiece, currentSpace: currentSpace, color: board.spaces[currentSpace], jumpedSpace: -1 });
                          selectedPiece = -1;
                        }
                        
                        //check if jumping opponent piece
                        if ((currentSpace === selectedPiece + 14 && j != 1 && (board.spaces[selectedPiece + 7] === opponentColor || board.spaces[selectedPiece + 7] === -opponentColor)) || 
                            (currentSpace === selectedPiece + 18 && j != 7 && (board.spaces[selectedPiece + 9] === opponentColor || board.spaces[selectedPiece + 9] === -opponentColor)) || 
                            (board.spaces[selectedPiece] === -userColor && 
                             ((currentSpace === selectedPiece - 14 && j != 1 && (board.spaces[selectedPiece - 7] === opponentColor || board.spaces[selectedPiece - 7] === -opponentColor)) ||
                              (currentSpace === selectedPiece - 18 && j != 7 && (board.spaces[selectedPiece - 9] === opponentColor || board.spaces[selectedPiece - 9] === -opponentColor))
                              ))) {
                          board.spaces[currentSpace] = board.spaces[selectedPiece];
                          board.spaces[(selectedPiece + currentSpace) / 2] = 0;
                          board.spaces[selectedPiece] = 0;
                          socket.emit('clientUpdate', { boardSpaces: board.spaces, pieceCount: pieceCount, selectedPiece: selectedPiece, currentSpace: currentSpace, color: board.spaces[currentSpace], jumpedSpace: (selectedPiece + currentSpace) / 2 });
                          selectedPiece = -1;
                        }
                      } else {
                        //check if moving into adjacent spaces
                        if ((currentSpace === selectedPiece - 7 && j != 0) || 
                            (currentSpace === selectedPiece - 9 && j != 8) || 
                            (board.spaces[selectedPiece] === -userColor && ((currentSpace === selectedPiece + 7 && j!= 0) || (currentSpace === selectedPiece + 9 && j != 8)))) {
                          board.spaces[currentSpace] = board.spaces[selectedPiece];
                          board.spaces[selectedPiece] = 0;
                          socket.emit('clientUpdate', { boardSpaces: board.spaces, pieceCount: pieceCount, selectedPiece: selectedPiece, currentSpace: currentSpace, color: board.spaces[currentSpace], jumpedSpace: -1 });
                          selectedPiece = -1;
                        }
                        
                        //check if jumping opponent piece
                        if ((currentSpace === selectedPiece - 14 && j != 1 && (board.spaces[selectedPiece - 7] === opponentColor || board.spaces[selectedPiece - 7] === -opponentColor)) || 
                            (currentSpace === selectedPiece - 18 && j != 7 && (board.spaces[selectedPiece - 9] === opponentColor || board.spaces[selectedPiece - 9] === -opponentColor)) || 
                            (board.spaces[selectedPiece] === -userColor && 
                             ((currentSpace === selectedPiece + 14 && j != 1 && (board.spaces[selectedPiece + 7] === opponentColor || board.spaces[selectedPiece + 7] === -opponentColor)) ||
                              (currentSpace === selectedPiece + 18 && j != 7 && (board.spaces[selectedPiece + 9] === opponentColor || board.spaces[selectedPiece + 9] === -opponentColor))
                              ))) {
                          board.spaces[currentSpace] = board.spaces[selectedPiece];
                          board.spaces[(selectedPiece + currentSpace) / 2] = 0;
                          board.spaces[selectedPiece] = 0;
                          socket.emit('clientUpdate', { boardSpaces: board.spaces, pieceCount: pieceCount, selectedPiece: selectedPiece, currentSpace: currentSpace, color: board.spaces[currentSpace], jumpedSpace: (selectedPiece + currentSpace) / 2 });
                          selectedPiece = -1;
                        }
                      }
                    }
                  }
                }
              }
            }
          };
          
          update();
        });
        
        socket.on('update', (data) => {
          pieceCount = data.pieceCount;
          board.spaces = data.boardSpaces;
          
          update();
        });
      }

      const canvasInit = () => {
        canvas = document.querySelector('canvas');
        ctx = canvas.getContext('2d');
        ctx.strokeRect(250, 230, 100, 40);
        ctx.textAlign = 'center';
        ctx.font = '15px Arial';
        ctx.fillText('Join', 300, 255);

        canvas.onclick = (e) => {
          if (clickedRectangle(e, 250, 230, 100, 40)) {
            ioInit();
          }
        };
      };

      const init = () => {
        canvasInit();
      };

      window.onload = init;
    }());
  </script>
  
  <style>
    body {
      width: 403px;
    }
    
    div {
      display: block;
      background-color: #EEEEEE;
      height: 306px;
      overflow-y: scroll;
    }
  </style>
</head>
<body>
  <canvas width="600" height="600"></canvas>
</body>
</html>